{
  "language": "Solidity",
  "sources": {
    "contracts/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental \"ABIEncoderV2\";\n\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { AddressArrayUtils } from \"./lib/AddressArrayUtils.sol\";\nimport { PreciseUnitMath } from \"./lib/PreciseUnitMath.sol\";\nimport { IOracleAdapter } from \"./interfaces/IOracleAdapter.sol\";\n\n\n/**\n * @title PriceOracle\n *\n * Contract that returns the price for any given asset pair. Price is retrieved either directly from an oracle,\n * calculated using common asset pairs, or uses external data to calculate price.\n * Note: Prices are returned in preciseUnits (i.e. 18 decimals of precision)\n */\ncontract PriceOracle is Ownable {\n\n    using PreciseUnitMath for uint256;\n    using AddressArrayUtils for address[];\n\n    /* ============ Events ============ */\n\n    event PriceAdded(address indexed _assetOne, address indexed _assetTwo, uint256 _price);\n    event PriceRemoved(address indexed _assetOne, address indexed _assetTwo);\n    event AdapterAdded(address _adapter);\n    event AdapterRemoved(address _adapter);\n    event MasterQuoteAssetEdited(address _newMasterQuote);\n\n\n    /* ============ State Variables ============ */\n\n    // Mapping between assetA/assetB and its associated price\n    // Asset 1 -> Asset 2 -> price\n    mapping(address => mapping(address => uint256)) public prices;\n\n    // Token address of the bridge asset that prices are derived from if the specified pair price is missing\n    address public masterQuoteAsset;\n\n    // List of IOracleAdapters used to return prices of third party protocols (e.g. Uniswap, Compound, Balancer)\n    address[] public adapters;\n\n    /* ============ Constructor ============ */\n\n    /**\n     * Initialize state variables\n     *\n     * @param _masterQuoteAsset       Address of asset that can be used to link unrelated asset pairs\n     * @param _adapters               List of adapters used to price assets created by other protocols\n     */\n    constructor(address _masterQuoteAsset, address[] memory _adapters) {\n        masterQuoteAsset = _masterQuoteAsset;\n        adapters = _adapters;\n    }\n\n    /* ============ External Functions ============ */\n\n    /**\n     * SYSTEM-ONLY PRIVELEGE: Find price of passed asset pair, if possible. The steps it takes are:\n     *  1) Check to see if a direct or inverse price of the pair exists,\n     *  2) If not, use masterQuoteAsset to link pairs together (i.e. BTC/ETH and ETH/USDC\n     *     could be used to calculate BTC/USDC).\n     *  3) If not, check oracle adapters in case one or more of the assets needs external protocol data\n     *     to price.\n     *  4) If all steps fail, revert.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     * @return                  Price of asset pair to 18 decimals of precision\n     */\n    function getPrice(address _assetOne, address _assetTwo) external view returns (uint256) {\n        (bool priceFound, uint256 price) = _getDirectOrInversePrice(_assetOne, _assetTwo);\n\n        if (!priceFound) {\n            (priceFound, price) = _getPriceFromMasterQuote(_assetOne, _assetTwo);\n        }\n\n        if (!priceFound) {\n            (priceFound, price) = _getPriceFromAdapters(_assetOne, _assetTwo);\n        }\n\n        require(priceFound, \"PriceOracle.getPrice: Price not found.\");\n\n        return price;\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Add new asset pair price.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     * @param _price            Price of assetOne per assetTwo\n     * @param _decimals         Price decimals\n     */\n    function feedPrice(\n        address _assetOne,\n        address _assetTwo,\n        uint256 _price,\n        uint8 _decimals\n    ) external onlyOwner {\n        prices[_assetOne][_assetTwo] = PreciseUnitMath.preciseDiv(_price, 10 ** _decimals);\n\n        emit PriceAdded(_assetOne, _assetTwo, _price);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Remove asset pair's price.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     */\n    function removePrice(address _assetOne, address _assetTwo) external onlyOwner {\n        require(\n            prices[_assetOne][_assetTwo] > 0,\n            \"PriceOracle.removePrice: Price doesn't exist.\"\n        );\n\n        delete prices[_assetOne][_assetTwo];\n\n        emit PriceRemoved(_assetOne, _assetTwo);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Add new oracle adapter.\n     *\n     * @param _adapter         Address of new adapter\n     */\n    function addAdapter(address _adapter) external onlyOwner {\n        require(\n            !adapters.contains(_adapter),\n            \"PriceOracle.addAdapter: Adapter already exists.\"\n        );\n        adapters.push(_adapter);\n\n        emit AdapterAdded(_adapter);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Remove oracle adapter.\n     *\n     * @param _adapter         Address of adapter to remove\n     */\n    function removeAdapter(address _adapter) external onlyOwner {\n        require(\n            adapters.contains(_adapter),\n            \"PriceOracle.removeAdapter: Adapter does not exist.\"\n        );\n        adapters = adapters.remove(_adapter);\n\n        emit AdapterRemoved(_adapter);\n    }\n\n    /**\n     * GOVERNANCE FUNCTION: Change the master quote asset.\n     *\n     * @param _newMasterQuoteAsset         New address of master quote asset\n     */\n    function editMasterQuoteAsset(address _newMasterQuoteAsset) external onlyOwner {\n        masterQuoteAsset = _newMasterQuoteAsset;\n\n        emit MasterQuoteAssetEdited(_newMasterQuoteAsset);\n    }\n\n    /* ============ External View Functions ============ */\n\n    /**\n     * Returns an array of adapters\n     */\n    function getAdapters() external view returns (address[] memory) {\n        return adapters;\n    }\n\n    /* ============ Internal Functions ============ */\n\n    /**\n     * Check if direct or inverse price exists. If so return that price along with boolean indicating\n     * it exists. Otherwise return boolean indicating price doesn't exist.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     * @return bool             Boolean indicating if price exists\n     * @return uint256          Price of asset pair to 18 decimal precision (if exists, otherwise 0)\n     */\n    function _getDirectOrInversePrice(\n        address _assetOne,\n        address _assetTwo\n    )\n        internal\n        view\n        returns (bool, uint256)\n    {\n        uint256 price = prices[_assetOne][_assetTwo];\n\n        // Check direct price (asset1 -> asset 2). If exists, then return value\n        // Has direct price\n        if (price > 0) {\n            return (true, price);\n        }\n\n        uint256 inversePrice = prices[_assetTwo][_assetOne];\n\n        // If not, check inverse price (asset 2 -> asset 1). If exists, then return 1 / asset1 -> asset2\n        if (inversePrice > 0) {\n            // Calculate inverse price. The inverse price is 1 (or 1e18) / inverse price\n            return (true, PreciseUnitMath.preciseUnit().preciseDiv(inversePrice));\n        }\n\n        return (false, 0);\n    }\n\n    /**\n     * Try to calculate asset pair price by getting each asset in the pair's price relative to master\n     * quote asset. Both prices must exist otherwise function returns false and no price.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     * @return bool             Boolean indicating if price exists\n     * @return uint256          Price of asset pair to 18 decimal precision (if exists, otherwise 0)\n     */\n    function _getPriceFromMasterQuote(\n        address _assetOne,\n        address _assetTwo\n    )\n        internal\n        view\n        returns (bool, uint256)\n    {\n        (bool priceFoundOne, uint256 assetOnePrice) = _getDirectOrInversePrice(_assetOne, masterQuoteAsset);\n        (bool priceFoundTwo, uint256 assetTwoPrice) = _getDirectOrInversePrice(_assetTwo, masterQuoteAsset);\n\n        if (priceFoundOne && priceFoundTwo) {\n            return (true, assetOnePrice.preciseDiv(assetTwoPrice));\n        }\n\n        return (false, 0);\n    }\n\n    /**\n     * Scan adapters to see if one or more of the assets needs external protocol data to be priced. If\n     * does not exist return false and no price.\n     *\n     * @param _assetOne         Address of first asset in pair\n     * @param _assetTwo         Address of second asset in pair\n     * @return bool             Boolean indicating if price exists\n     * @return uint256          Price of asset pair to 18 decimal precision (if exists, otherwise 0)\n     */\n    function _getPriceFromAdapters(\n        address _assetOne,\n        address _assetTwo\n    )\n        internal\n        view\n        returns (bool, uint256)\n    {\n        for (uint256 i = 0; i < adapters.length; i++) {\n            (bool priceFound, uint256 price) = IOracleAdapter(adapters[i]).getPrice(_assetOne, _assetTwo);\n\n            if (priceFound) {\n                return (priceFound, price);\n            }\n        }\n\n        return (false, 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/lib/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\nlibrary AddressArrayUtils {\n\n    /**\n     * @dev Finds the index of the first occurrence of the given element.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns (index and isIn) for the first occurrence starting from index 0\n     */\n    function indexOf(address[] memory A, address a) internal pure returns (uint256, bool) {\n        uint256 length = A.length;\n        for (uint256 i = 0; i < length; i++) {\n            if (A[i] == a) {\n                return (i, true);\n            }\n        }\n        return (uint256(0), false);\n    }\n\n    /**\n     * Returns true if the value is present in the list. Uses indexOf internally.\n     * @param A The input array to search\n     * @param a The value to find\n     * @return Returns isIn for the first occurrence starting from index 0\n     */\n    function contains(address[] memory A, address a) internal pure returns (bool) {\n        (, bool isIn) = indexOf(A, a);\n        return isIn;\n    }\n\n    /**\n     * @param A The input array to search\n     * @param a The address to remove\n     * @return Returns the array with the object removed.\n     */\n    function remove(address[] memory A, address a)\n        internal\n        pure\n        returns (address[] memory)\n    {\n        (uint256 index, bool isIn) = indexOf(A, a);\n        require(isIn, \"Address not in array.\");\n        (address[] memory _A,) = pop(A, index);\n        return _A;\n    }\n\n    /**\n     * @dev Removes specified index from array\n     * @param A The input array to search\n     * @param index The index to remove\n     * @return Returns the new array and the removed entry\n     */\n    function pop(address[] memory A, uint256 index)\n        internal\n        pure\n        returns (address[] memory, address)\n    {\n        uint256 length = A.length;\n        require(index < A.length, \"Index must be < A length\");\n        address[] memory newAddresses = new address[](length - 1);\n        for (uint256 i = 0; i < index; i++) {\n            newAddresses[i] = A[i];\n        }\n        for (uint256 j = index + 1; j < length; j++) {\n            newAddresses[j - 1] = A[j];\n        }\n        return (newAddresses, A[index]);\n    }\n}\n"
    },
    "contracts/lib/PreciseUnitMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\npragma experimental ABIEncoderV2;\n\nlibrary PreciseUnitMath {\n\n    // The number One in precise units.\n    uint256 constant internal PRECISE_UNIT = 10 ** 18;\n\n    /**\n     * @dev Getter function since constants can't be read directly from libraries.\n     */\n    function preciseUnit() internal pure returns (uint256) {\n        return PRECISE_UNIT;\n    }\n\n    function preciseDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * PRECISE_UNIT / b;\n    }\n}\n"
    },
    "contracts/interfaces/IOracleAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.4;\n\n\n/**\n * @title IOracleAdapter\n * @author Set Protocol\n *\n * Interface for calling an oracle adapter.\n */\ninterface IOracleAdapter {\n\n    /**\n     * Function for retrieving a price that requires sourcing data from outside protocols to calculate.\n     *\n     * @param  _assetOne    First asset in pair\n     * @param  _assetTwo    Second asset in pair\n     * @return                  Boolean indicating if oracle exists\n     * @return              Current price of asset represented in uint256\n     */\n    function getPrice(address _assetOne, address _assetTwo) external view returns (bool, uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}